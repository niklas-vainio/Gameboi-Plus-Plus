import requests
import os
from datetime import datetime
from dataclasses import dataclass

FILE_HEADER_CPP = """\
/**
 * {description}
 * 
 * File skeleton generated by scripts/generate_instruction_code.py
 * 
 * @author Niklas Vainio
 * @date   {date}
 */

#include "Cpu.hpp"
#include "common/logging.hpp"
#include <format>
 
namespace Gbpp::Backend 
{{

"""

FILE_FOOTER_CPP = """\
} // namespace Gbpp::Backend
"""

FILE_HEADER_HPP = """\
/**
 * {description}
 * 
 * Auto-generated by scripts/generate_instruction_code.py
 * Do not edit manually!
 * 
 * @author Niklas Vainio
 * @date   {date}
 */

"""

BLOCK_COMMENT = """\
/*
 * ============================================================================
 * {comment}
 * ============================================================================
 */

"""

# Function declaration in .h file
FUNCTION_PROTOTYPE = """\
void instruction_{opcode:02X}_{mnemonic}();
"""

CB_FUNCTION_PROTOTYPE = """\
void instruction_CB_{opcode:02X}_{mnemonic}();
"""

ILLEGAL_FUNCTION_PROTOTYPE = """\
void instruction_ILLEGAL();
"""

# Function stub in .cpp file
FUNCTION_STUB = """\
void Cpu::instruction_{opcode:02X}_{mnemonic}() 
{{
    /*
     * {mnemonic} {operands}
     * Flags: {flags}
     * Cycles: {cycles}
     */

    current_instruction_asm = std::format("{mnemonic} {gb_font_operands}");
}}

"""

CB_FUNCTION_STUB = """\
void Cpu::instruction_CB_{opcode:02X}_{mnemonic}() 
{{
    /*
     * {mnemonic} {operands}
     * Flags: {flags}
     * Cycles: {cycles}
     */

    current_instruction_asm = std::format("{mnemonic} {gb_font_operands}");
}}

"""

ILLEGAL_FUNCTION_STUB = """\
void Cpu::instruction_ILLEGAL() 
{
    /*
     * Catch-all for illegal opcodes. Log an error and do nothing.
     */
    LogError("Encoutered invalid opcode 0x%02X at PC = 0x%04X", opcode, pc - 1);
    current_instruction_asm = std::format("ILLEGAL {:02X}", opcode);
}

"""

# Struct for opcode metadata
INSTRUCTION_STRUCT = """\
    {{&Cpu::instruction_{opcode:02X}_{mnemonic}, 0x{opcode:02X}, {bytes}, {cycles}}},
"""

INSTRUCTION_STRUCT_CB = """\
    {{&Cpu::instruction_CB_{opcode:02X}_{mnemonic}, 0x{opcode:02X}, {bytes}, {cycles}}},
"""

INSTRUCTION_STRUCT_ILLEGAL = """\
    {{&Cpu::instruction_ILLEGAL, 0x{opcode:02X}, {bytes}, {cycles}}},
"""


# Generate: function .h declaration, .cpp stub, struct

@dataclass
class Instruction:
    opcode: int
    mnemonic: str
    operands: str
    gb_font_operands: str
    flags: str
    bytes: int
    cycles: int


def extract_opcodes(data: dict) -> tuple:
    # Extract opcodes from raw JSON

    unprefixed: dict = data["unprefixed"]
    cb_prefixed: dict = data["cbprefixed"]

    unprefixed_instructions = [
        Instruction(
            opcode=int(opcode, 16),
            mnemonic="ILLEGAL" if "ILLEGAL" in info["mnemonic"] else info["mnemonic"],
            operands=", ".join(
                (operand["name"] if operand["immediate"] else "[" + operand["name"] + "]") 
                for operand in info["operands"]
            ),
            gb_font_operands=", ".join(
                (operand["name"] if operand["immediate"] else "*" + operand["name"]) 
                for operand in info["operands"]
            ),                                       
            flags=" ".join([info["flags"]["Z"], info["flags"]["N"], info["flags"]["H"], info["flags"]["C"]]),
            bytes=info["bytes"],
            cycles=min(info["cycles"]),
        )
        for opcode, info in unprefixed.items()
    ]

    # Manually override the CB instructon itself, which is handled separately
    unprefixed_instructions[0xCB] = Instruction(
        opcode=0xCB,
        mnemonic="ILLEGAL",
        operands="",
        gb_font_operands="",
        flags="",
        bytes=1,
        cycles=4,
    )

    cb_prefixed_instructions = [
        Instruction(
            opcode=int(opcode, 16),
            mnemonic="ILLEGAL" if "ILLEGAL" in info["mnemonic"] else info["mnemonic"],
            operands=", ".join(
                (operand["name"] if operand["immediate"] else "[" + operand["name"] + "]") 
                for operand in info["operands"]
            ),
            gb_font_operands=", ".join(
                (operand["name"] if operand["immediate"] else "*" + operand["name"]) 
                for operand in info["operands"]
            ),
            flags=" ".join([info["flags"]["Z"], info["flags"]["N"], info["flags"]["H"], info["flags"]["C"]]),
            bytes=info["bytes"],
            cycles=min(info["cycles"]),
        )
        for opcode, info in cb_prefixed.items()
    ]

    return unprefixed_instructions, cb_prefixed_instructions


def generate_function_stubs(unprefixed: list[Instruction], cb_prefixed: list[Instruction]):
    with open("scripts/generated/instructions.cpp", "w") as file:
        file.write(FILE_HEADER_CPP.format(description="CPU instruction implementations.",
                                      date=datetime.now().strftime("%Y-%m-%d")))

        file.write(ILLEGAL_FUNCTION_STUB)

        file.write(BLOCK_COMMENT.format(comment="Unprefixed Instructions"))

        for instr in unprefixed:
            if instr.mnemonic != "ILLEGAL":
                file.write(FUNCTION_STUB.format(**instr.__dict__))

        file.write(BLOCK_COMMENT.format(comment="CB-Prefixed Instructions"))

        for instr in cb_prefixed:
            if instr.mnemonic != "ILLEGAL":
                file.write(CB_FUNCTION_STUB.format(**instr.__dict__))

        file.write(FILE_FOOTER_CPP)


def generate_function_prototypes(unprefixed: list[Instruction], cb_prefixed: list[Instruction]):
    with open("scripts/generated/instruction_prototypes.hpp", "w") as file:
        file.write(FILE_HEADER_HPP.format(description="CPU instruction function prototypes.",
                                      date=datetime.now().strftime("%Y-%m-%d")))
        file.write(ILLEGAL_FUNCTION_PROTOTYPE)

        for instr in unprefixed:
            if instr.mnemonic != "ILLEGAL":
                file.write(FUNCTION_PROTOTYPE.format(**instr.__dict__))
        for instr in cb_prefixed:
            if instr.mnemonic != "ILLEGAL":
                file.write(CB_FUNCTION_PROTOTYPE.format(**instr.__dict__))


def generate_instruction_structs(unprefixed: list[Instruction], cb_prefixed: list[Instruction]) -> str:
    with open("scripts/generated/instruction_map.hpp", "w") as file:
        file.write(FILE_HEADER_HPP.format(description="Metadata for unprefixed CPU instructions.",
                                      date=datetime.now().strftime("%Y-%m-%d")))
        
        file.write("static constexpr std::array<Instruction, 256> instruction_map = {{\n")
        for instr in unprefixed:
            if instr.mnemonic == "ILLEGAL":
                file.write(INSTRUCTION_STRUCT_ILLEGAL.format(**instr.__dict__))
            else:
                file.write(INSTRUCTION_STRUCT.format(**instr.__dict__))
        file.write("}};\n")

    with open("scripts/generated/instruction_map_cb_prefixed.hpp", "w") as file:
        file.write(FILE_HEADER_HPP.format(description="Metadata for CB-prefixed CPU instructions.",
                                      date=datetime.now().strftime("%Y-%m-%d")))
        file.write("static constexpr std::array<Instruction, 256> instruction_map_cb_prefixed = {{\n")
        for instr in cb_prefixed:
            if instr.mnemonic == "ILLEGAL":
                file.write(INSTRUCTION_STRUCT_ILLEGAL.format(**instr.__dict__))
            else:
                file.write(INSTRUCTION_STRUCT_CB.format(**instr.__dict__))
        file.write("}};\n")

if __name__ == "__main__":
    # Fetch opcode data
    OPCODE_JSON_URL = "https://gbdev.io/gb-opcodes/Opcodes.json"

    data = requests.get(OPCODE_JSON_URL).json()
    unprefixed_instructions, cb_prefixed_instructions = extract_opcodes(data)

    os.makedirs("scripts/generated", exist_ok=True)
    generate_function_stubs(unprefixed_instructions, cb_prefixed_instructions)
    generate_function_prototypes(unprefixed_instructions, cb_prefixed_instructions)
    generate_instruction_structs(unprefixed_instructions, cb_prefixed_instructions)

    print("")
    print("Done! See results in scripts/generated/")
    print("")